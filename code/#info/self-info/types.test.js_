/*
 * Copyright Â© 2020-2023 Metreeca srl
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var core=require("src/main/node.js/core");


describe("type test", function () {

	var types={

		"undefined": { value: undefined, tests: [core.isNil] },
		"null": { value: null, tests: [core.isNil] },

		"boolean literal": { value: true, tests: [core.isBoolean] },
		"number literal": { value: 123, tests: [core.isNumber] },
		"string literal": { value: "xyz", tests: [core.isString] },

		"boolean wrapper": { value: new Boolean(true), tests: [core.isBoolean] },
		"number wrapper": { value: new Number(123), tests: [core.isNumber] },
		"string wrapper": { value: new String("xyz"), tests: [core.isString] },

		"array": { value: [1, 2, 3], tests: [core.isArray, core.isList] },
		"array-like": { value: { 1: 1, 2: 2, 3: 3, length: 3 }, tests: [core.isList, core.isObject] },

		"object": { value: {}, tests: [core.isObject] },
		"function": { value: function () {}, tests: [core.isFunction] },

		"Node": { value: window.document, tests: [core.isNode] },
		"NodeList": { value: window.document.querySelectorAll("body"), tests: [core.isList, core.isNodeList] },
		"HTMLCollection": { value: document.documentElement.children, tests: [core.isList, core.isNodeList] },
		"Event": { value: new window.CustomEvent("test"), tests: [core.isEvent] }
	};

	var tests=[]; // collect type tests

	for (var t in types) {
		if ( types.hasOwnProperty(t) ) {
			for (var i=0; i < types[t].tests.length; ++i) {

				var type=types[t];
				var test=type.tests[i];

				if ( tests.indexOf(test) < 0 ) {
					tests.push(test);
				}
			}
		}
	}

	for (var i=0; i < tests.length; ++i) { // build type-specific specs

		var test=tests[i];

		describe(/function (\w+)/.exec(test)[1]+"()", function () {

			for (var t in types) {
				if ( types.hasOwnProperty(t) ) {
					should(test, t, types[t].value, types[t].tests.indexOf(test) >= 0);
				}
			}

		});
	}

	function should(test, type, value, expected) {
		if ( expected ) {
			it("accepts "+type, function () { expect(test(value)).toBe(true) });
		} else {
			it("rejects "+type, function () { expect(test(value)).toBe(false); });
		}
	}

});

describe("type test isList()", function () {

	it("accepts empty lists", function () {
		expect(core.isList({ length: 0 })).toBe(true);
	});

	it("rejects negative lengths", function () {
		expect(core.isList({ length: -1 })).toBe(false);
	});

});
